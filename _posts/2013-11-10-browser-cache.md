---
layout: post
title:  "浏览器缓存"
date:   2013-11-10 20:48:28
categories: posts
tags: cache
---
整天和浏览器打交道，“缓存”这个东西是绕不过去的。有时候修改了文件，大喊一声“为什么不起作用？”，那多半是缓存的原因。这东西有时候很惹人烦，特别对于开发者来说。但应该说绝大多数情况下，它是个好东西：合理利用好缓存，可以极大提高站点的用户体验。<!-- more -->缓存通常分为多种类型，我们这里只说浏览器缓存。

---

## 缓存的一些规则

对于所有缓存来说，通常都是基于一套规则，来决定是否从缓存中获取副本来使用。部分规则来自于协议方面（比如 HTTP 1.0 和 1.1），而部分则来自于用户、服务器管理员等。

通常来讲，以下是最常见的一部分规则：

1. 如果服务器响应的头部告知浏览器不缓存，那响应的内容则不会被缓存
2. 如果该次请求是用于身份验证，或是基于安全协议（如 HTTPS），则不能被共享缓存所处理
3. 一个缓存副本，在以下情况下，会被认为是有效的，足够新鲜(fresh)的，拿来即用，无需再次请求服务器：
    - 副本存在一个过期时间或者其它包含有效期的头部设置，并且仍处于有效时间内
    - 浏览器已经使用过这个副本，并且已验证过有效性
4. 如果一个副本过了有效期，浏览器会向服务器发起验证的请求，以确定副本是否仍然有效
5. 在某些确定的情况下，比如，网络断开联接，这时会直接使用缓存副本，即使是过期的

在服务器的响应中，如果不包含任何验证相关的头部（ETag 或 Last-Modified），也不存在任何标识有效期的信息，那么通常情况下，该响应是不可被缓存的。

**新鲜度** 和 **有效性** 是最重要的两个概念。一个新鲜的副本可以拿来即用，而一个有效的副本可以避免服务器在文件没发生改变的情况下再次发送整个文件的内容。

## 如何控制缓存

有两种途径控制缓存：

- 通过 HTML 的 `meta` 标签

使用 `meta` 标签可以控制页面不被缓存，或者设置某个有效期限

{% highlight html %}
<meta http-equiv="pragma" content="no-cache" />
<!-- or -->
<meta http-equiv="expires" content="1 Apr 2099" />
{% endhighlight %}

这个方法虽然简单，但不是很效。由于不被所有浏览器支持，并且对代理服务器无效，所以通常不使用这种方法。

- 通过 HTTP 头部

这种方法给予我们更多的控制权，可以更细致地利用缓存，下面详细说说。

## Expires

`Expires` 头部是控制缓存的基本手段，它告诉浏览器缓存副本的有效期限。过了那个期限之后，会再次向服务器发起请求。它的值必须是合法的 `HTTP-date` 格式，任何其他格式的值，都会被认为 **已经过期**。

比如：

```
Expires: Thu, 01 Dec 1994 16:00:00 GMT
```

`Expires` 对于一些静态资源，比如图片，非常有用。通常来讲，这些资源不会被频繁改变，所以可以设置一个相对较长的有效期限。另外，对于一些有规律性更新的页面也很有用，比如一个页面每天6点都会被更新，那就可以根据这个规律来设置 `Expires` 了。

虽然 `Expires` 很有用，但也有一些缺陷：

- 首先，它依赖于时间，这就要求服务器的时间和客户端的要保持同步，否则可能会有意外。
- 另外，如果在过期时间之前，忘了重新设置它的值，也有可能达不到我们想要的缓存效果。

## Cache-Control

`Cache-Control` 这个头部字段是在 `HTTP 1.1` 新增的，它给了我们更多的控制选项，也避免了 `Expires` 的缺陷。`Cache-Control` 与 `Expires` 同时存在时，前者优先级较高。它常见的值有：

- `public` - （响应）表明资源可以被任何缓存区缓存。
- `private` - （响应）表明响应的部分或者全部信息只对单个用户有效，并且不能被共享缓存处理。这允许源服务器只对单个用户作出相应的响应，此响应对其他用户的请求无效。这个值对于共享缓存无效。
- `no-cache` - （请求或响应）如果是在请求中，表明客户端不希望接收到缓存的副本（无论有没有过期），它要求了缓存服务器向源服务器进行资源的再次验证。如果是在响应中，表明了源服务器允许缓存服务器对资源进行缓存，但是每次使用前，都需要向源服务器再次认验。
- `max-age` - （请求或响应）单位为秒，相对于资源产生时的时间。如果是在请求中，表明客户端可以接收生存期(age)不大于指定时间的响应；如果是存在于响应中，则指定了这个资源的缓存副本的有效时长。
- `s-maxage` - （响应）与 `max-age` 相似，只不过这个只作用于共享缓存（比如代理服务器缓存）。如果同时也存在 `max-age`，后者会被覆盖。
- `no-store` - （请求或响应）为了防止敏感信息被无意地泄露。如果是在请求中，那么这个请求以及它的响应都不能被缓存；相应地，如果是通过响应发送的，那么这个响应以及对应的请求也不能被缓存。这个值对非共享以及共享缓存均起作用。
- `min-fresh` - （请求）单位为秒。表明客户端要求这个资源再过 xx 秒后，仍然是新鲜的。
- `max-stale` - （请求）可能有值，也可能没值。如果有值，其单位为秒，表明客户端可以接收已经超出有效期但是超出的时间不大于指定时间的响应；如果没有一个明确的值，表明客户端可以接收任何已经超出有效期的响应。

## Last-Modified & If-Modified-Since

`Last-Modified` 表示某个资源的最后修改时间，服务器在响应请求时，一并发送。

如果某个缓存的资源已经过了有效期，并且它包含 `Last-Modified` 信息，那么浏览器再次向服务器请求时，在头部会带上 `If-Modified-Since` ，询问服务器该资源在这个时间后是否被修改过。如果是，服务器将返回最新的资源，状态码 `200`；否则，服务器只需返回 `304`，告知浏览器资源没有被修改，可以直接使用缓存。

## ETag & If-None-Match

除了上面的 `Last-Modified`，`HTTP 1.1` 新增了一个较验类型 `ETag`，它表示资源的唯一标识符，由服务器根据某些规则生成。

如果某个缓存的资源已经过了有效期，并且它包含 `ETag` 信息，那么浏览器再次向服务器请求时，在头部会带上 `If-None-Match` ，询问服务器该资源是否被修改过。如果是，服务器将返回最新的资源，状态码 `200`；否则，服务器只需返回 `304`，告知浏览器资源没有被修改，可以直接使用缓存。

那么，既然已经有了上面的 `Last-Modified` 以及 `If-Modified-Since`，为什么还需要 `ETag` 和 `If-None-Match` 呢？

`ETag` 的出现，主要是为了解决 `If-Modified-Since` 解决不了的几个问题：

- `Last-Modified` 只精确到秒，如果文件在1秒钟内被修改多次，则不能准备标识文件的修改时间
- `Last-Modified` 依赖于时间，这时间有可能存在不同步等偏差问题
- 如果某些文件会被定期生成，但内容有时并没有发生变化，而 `Last-Modified` 却改变了，导致缓存失效

综上，`ETag` 可以让我们更精确地控制缓存，并且它的优先级高于 `Last-Modified`。

## 用户操作行为与缓存

用户在使用浏览器，一些操作比如地址栏回车，F5 刷新等等，这些行为对缓存有一定的影响。

用户操作 | Expires/Cache-Control | Last-Modified/ETag
--------|-----------------------|-------------------
地址栏回车        | 有效    | 有效
页面链接跳转      | 有效    | 有效
新开窗口          | 有效    | 有效
前进、后退        | 有效    | 有效
F5刷新           | **无效**    | **有效**
Ctrl + F5刷新    | **无效**    | **无效**

从上表得知，当使用 F5 刷新时，`Expires/Cache-Control` 的设置会被忽略，这时 `Last-Modified/ETag` 就起了作用。所以将这些规则结合起来用是非常推荐的。

---

## 参考链接

- [Caching Tutorial][1]
- [Header Field Definitions][2]

[1]: https://www.mnot.net/cache_docs/
[2]: https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html
